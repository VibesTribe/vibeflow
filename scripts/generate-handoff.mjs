// scripts/generate-handoff.mjs
import fs from "node:fs/promises";
import path from "node:path";

const ROOT = path.resolve(process.cwd());
const STATE_FILE = path.join(ROOT, "data", "state", "task.state.json");
const LEDGER_DIR = path.join(ROOT, "data", "ledger");
const UPDATES_DIR = path.join(ROOT, "docs", "updates");

function fmt(n){ return new Intl.NumberFormat("en-US", {maximumFractionDigits: 2}).format(n || 0); }

async function maybeRead(p, fallback=null){
  try { return JSON.parse(await fs.readFile(p,"utf8")); } catch { return fallback; }
}

async function aggregateCosts(){
  try {
    const entries = await fs.readdir(LEDGER_DIR);
    let totals = { vibeflow_cost_usd:0, counterfactual_api_cost_usd:0, savings_usd:0, roi_percent:0 };
    for(const f of entries){
      if(!f.endsWith(".json")) continue;
      const j = await maybeRead(path.join(LEDGER_DIR,f), null);
      if(!j || !j.totals) continue;
      totals.vibeflow_cost_usd += j.totals.vibeflow_cost_usd || 0;
      totals.counterfactual_api_cost_usd += j.totals.counterfactual_api_cost_usd || 0;
      totals.savings_usd += j.totals.savings_usd || 0;
    }
    totals.roi_percent = totals.vibeflow_cost_usd > 0 ? (totals.savings_usd / totals.vibeflow_cost_usd) * 100 : 0;
    return totals;
  } catch { return null; }
}

async function main(){
  await fs.mkdir(UPDATES_DIR, { recursive: true });
  const state = await maybeRead(STATE_FILE, { tasks:[], slices:[], stats:{ totals:{}, costs:{} } });
  const date = new Date().toISOString().slice(0,10);
  const fpath = path.join(UPDATES_DIR, `handoff_${date}.md`);

  const totals = state?.stats?.totals || {};
  const costs = await aggregateCosts() || state?.stats?.costs || {};

  const completed = (state.tasks || []).filter(t => t.status === "done").map(t => `- ${t.task_id} ${t.title || ""}`);
  const running = (state.tasks || []).filter(t => t.status === "running").map(t => `- ${t.task_id} ${t.title || ""}`);
  const queued = (state.tasks || []).filter(t => t.status === "queued").map(t => `- ${t.task_id} ${t.title || ""}`);
  const failed  = (state.tasks || []).filter(t => t.status === "failed").map(t => `- ${t.task_id} ${t.title || ""} (${t.reason || ""})`);

  const md = `# Handoff â€” ${date}

## Completed (${completed.length})
${completed.join("\n") || "- None"}

## In Progress (${running.length})
${running.join("\n") || "- None"}

## Queued (${queued.length})
${queued.join("\n") || "- None"}

## Blockers / Failed (${failed.length})
${failed.join("\n") || "- None"}

## Telemetry
- Project ROI: ${fmt(costs.roi_percent)}% (CF $ ${fmt(costs.counterfactual_api_cost_usd)} vs VF $ ${fmt(costs.vibeflow_cost_usd)}; savings $ ${fmt(costs.savings_usd)})
- Totals: ${fmt(totals.tasks || 0)} tasks, ${fmt(totals.completed || 0)} done, ${fmt(totals.running || 0)} running, ${fmt(totals.queued || 0)} queued

## Notes
- Auto-generated by generate-handoff.mjs
`;

  await fs.writeFile(fpath, md, "utf8");
  console.log("Wrote", fpath);
}

main().catch(err => { console.error(err); process.exit(1); });
